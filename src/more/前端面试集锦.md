---
title: 前端面试集锦
createTime: 2025/11/13 21:03:04
permalink: /more/interview/
---

## HTML

### 什么是 <!DOCTYPE>？是否需要在 HTML5 中使用？

它是 HTML 的文档声明，通过它告诉浏览器，使用哪一个 HTML 版本标准进行解析文档。

在浏览器发展的历史中，HTML 出现过很多个版本，不同的版本在元素、属性等书写格式上略有差异，如果不预先告诉浏览器，浏览器就不知道我们的文档标准是什么，在这种情况下，大部分浏览器将开启最大兼容模式来解析网页，我们称之为怪异模式。这不仅会降低解析效率，而且会在解析过程中产生一些难以预知的 bug，所以文档声明是必须的。

而文档声明有多种书写格式，对应不同的 HTML 版本，<!DOCTYPE> 这种书写是告诉浏览器，整个文档使用 HTML5 的标准进行解析。

## 计算机网络

### 为什么 HTTP1.1 不能实现多路复用？

HTTP/1.1 不是二进制传输，而是通过文本进行传输。

由于没有流的概念，在使用并进行传输（多路复用）传递数据时，接受端在接收到相应后，并不能区分多个响应分别对应的请求，所以无法将多个响应的结果重新进行组装，也就实现不了多路复用。

### 谈谈你对 TCP 三次握手和四次挥手的理解？

TCP 协议通过三次握手建立可靠的点对点连接，具体过程是：

首先服务器进入监听状态，然后即可处理连接

**第一次握手**

建立连接时，客户端发送 SYN 包到服务器，并进入 SYN_SENT 状态，等待服务器确认。在发送的包中还会包含一个初始序列号 SEQ 。此次握手的含义是客户端希望与服务器建立连接。

**第二次握手**

服务器收到 SYN 包，然后回应给客户端一个 SYN + ACK 包，此时服务器进入 SYN_RCVD 状态。此次握手的含义是服务端回应客户端，表示已收到并同意客户端的连接请求。

**第三次握手**

客户端收到服务器的 SYN 后，向服务器再次发送 ACK 包，并进入 ESTAB_LISHEN 状态。

最后，服务端收到客户端的 ACK 包，于是也进入 ESTAB_LISHEN 状态，至此，连接建立完成。

当需要关闭连接时，需要进行四次挥手才能关闭

1. Client 想 Server 发送 FIN 包，表示 Client 主动要关闭连接，然后进入 FIN_WAIT_1 状态，等待 Server 返回 ACK 包。此后 Client 不能再向 Server 发送数据，但能读取数据。
2. Server 收到 FIN 包后向 Client 发送 ACK 包，然后进入 CLOSE_WAIT 状态，此后 Server 不能再读取数据，但可以继续向 Client 发送数据。
3. Client 收到 Server 返回的 ACK 包后进入 FIN_WAIT_2 状态，等待 Server 发送 FIN 包。
4. Server 完成数据的发送后，将 FIN 包发送给 Client，然后进入 LAST_ACK 状态，等待 Client 返回 ACK 包，此后 Server 既不能读取数据，也不能发送数据。
5. Client 收到 FIN 包后向 Server 发送 ACK 包，然后进入 TIME_WAIT 状态，接着等待足够长的时间（2MSL）以确保 Server 接收到 ACK 包，最后回到 CLOSED 状态，释放网络资源。
6. Server 收到 Client 返回的 ACK 包后便回到 CLOSED 状态，释放网络资源。

---

## ES6

### Promise

```javascript
const promise = new Promise((resolve, reject) => {
  console.log(1);
  resolve();
  console.log(2);
});

promise.then(() => {
  console.log(3);
});

console.log(4);
```

参考答案：1 2 4 3

```javascript
const promise = new Promise((resolve, reject) => {
  console.log(1);
  setTimeout(() => {
    console.log(2);
    resolve();
    console.log(3);
  }, 0);
});

promise.then(() => {
  console.log(4);
});

console.log(5);
```

参考答案：1 5 2 3 4

```javascript
const promise1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve();
  }, 1000);
});

const promise2 = promise1.catch(() => {
  return 2;
});

console.log("promise1", promise1);
console.log("promise1", promise1);

setTimeout(() => {
  console.log("promise1", promise1);
  console.log("promise1", promise1);
}, 2000);
```
